인터페이스 분리 원칙
-> 여러 개 만들지 말고 한개만 만들어라

의존성 역전 원칙
-> ex)질럿을 보는게 아니라 프로토스를 봐야 한다

추상클래스는 NEW불가

NEW할때 타입 결정할 수 있따(제네릭)
STATIC, 싱글톤 으로 설계하면 GENERIC설계 불가

ARRAYLIST
SET - 중복방지
HASHMAP -> 키값으로 찾는 거

람다 -CTRL + SPACE
STREAM API
MAP, FILTER

OS레벨의 데이터 타입 = 스트림
BYTE를 관리

바이트스트림의 단점 - 하나씩 밖에 입출력 됨
-> 버퍼(보조스트림)를 쓴다

멀티스레드 - 동시에 실행되는 것 처럼 보이지만 실제로는 컨텍스트스위칭(왔다갔다)이 일어나는것

TCP - OS레벨에서 자동으로 일어나는 것
UDP - 동영상스트리밍에 유리 
소켓 - 애플리케이션과 OS의 매개체(이 둘을 연결해주는 것) 소켓은 포트를 가진다 

스트림을 통해 흘러내려간다

패킷(주소를 알기위해) 
세그먼트(재조립을 위해)

버퍼, 소켓, IP, 포트, 리스너

서버소켓 - 요청을 받아들이는 것(연결할 때 쓴다), 랜덤 소켓을 만들어지고 랜덤 소켓은 클라이언트가 만들어진다
서버소켓은 임무를 다하면 소멸 된다.








반이중 : 양방향 전송이 가능하지만 동시에 양쪽 방향으로 전송 불가 ex) 무전기
전이중 : 실시간으로 된다 ex) 전화



bw           br
클 -----------> 서
   <-----------              	
br            bw

리드스레드
라이트스레드 만들고


1. 서버 생성
2. 클라이언트 생성
3. 클 -> 서버(메시지를 지속적으로 전송)
4. 서버 -> 클(메시지를 지속적으로 전송) >> 스레드



전이중 - statefull
반이중 - stateless


버퍼에 사진은 어떻게 담을까?
-> 사진은 결국 파일, 파일리더로 읽고 바이트리더로 변환시켜 전송
사진은 바이트스트림을 통해 내려간다 사진을 바이트로 쪼개서 전송시켜야
소켓을 타고 사진을 흘려 보내면 

헤더는 1460바이트

프레임: 네트워크에서 데이터를 전송할 때 사용되는 단위 패킷이라는 프레임의 형태로 전송된다

통신에서 확장자는 의미 없다.


확장자는 파일에 대한 프로토콜

HTTP 프로토콜은 몇 입씩 먹을 지 정해야 한다
프로토콜 정의는 APP이 한다
HTTP는 우리가 이해하고 구현할 줄 알아야한다.


1. 언어
2. 툴(write, read)


논문(팀 버너스리) 툴(Browser = chrome 같은)

브라우저는 리드만 가능
그럼 작성은?
평소에 자신들이 사용하던 툴로...

마크업 - 어떤 글자를 마킹해서 표시하는 것 ex)얘는 ~~~다.

<h1>안녕</h1>
메모장에는 보시다시피 이렇게 열림
<heading1> -> 글자를 제목 1로 표시하라 (마크업) -> 프레임텍스트에 표시하는 것
그러나 브라우저에서 뷰어 프로그램으로 보면

안녕

>>뷰어로 보면 예쁘게 보인다

밑줄을 긋고 싶다?
<u>안녕<u>
안녕(밑줄) 

<> = 마크업 랭귀지

마크업 랭귀지는 20개 정도
논문에 필요한 디자인만 만들었음
확장자를 .html

그 html이 브라우저이다

html = hyper text markup language

하이퍼텍스트
1. HTML내용이 길어도 스크롤로 해결이 된다
2. 논문에는 각주가 걸려있다 (어려운 용어는 출처)
-> 각주는 <a>각주</a> 링크가 걸리게 된다(내 글자를 날리고 새로운 글자를 열게함)
>>>이것이 하이퍼텍스트의 원리(하이퍼텍스트가 있는 마크업랭귀지)

web서버
>> html이 무수히 많이 들고 있음
>> 논문작성자들이 필요로함 이미 작성된 논문을 알아보기 위함

























